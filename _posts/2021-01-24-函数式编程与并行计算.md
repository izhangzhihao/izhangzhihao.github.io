---
layout: slide
title: å‡½æ•°å¼ç¼–ç¨‹ä¸å¹¶è¡Œè®¡ç®—
theme: night
# beige black blood league moon night serif simple sky solarized white
# taken from https://github.com/scateu/scateu.github.io/blob/master/_posts/2016-12-30-reveal-demo.md
transition: slide 
# none/fade/slide/convex/concave/zoom  #concaveå¯èƒ½ä¼šä½¿iOSçš„Safariå´©æºƒ
ruby_notation: true
diagram: true
mathjax: true
multiplex:
  id: 99702b17e6a745f9 #Secret: 14830192734523284320
  url: https://multiplex.scateu.me
  #url: https://reveal-js-multiplex-ccjbegmaii.now.sh
# DONE: æŠŠrogueç€è‰²å™¨åœ¨è¿™é‡Œå…³æ‰ï¼Œæˆ–è€…åœ¨å…¨å±€å…¨éƒ¨ç”¨highlight.jsæ¥ç€è‰²
# TODO: https://github.com/webpro/reveal-md
# DONE: æƒ³ä¸€ä¸ªæ›´ä¼˜é›…çš„åŠæ³•æ¥å¤„ç†multiplex
# HELP: <section markdown="1"> </section>ä¸ºåˆ†éš”
# HELP: <aside class="notes"> </aside> ä¸ºæ³¨è®°
---

<section markdown="1">

# å‡½æ•°å¼ç¼–ç¨‹ä¸å¹¶è¡Œè®¡ç®—

</section>

<section markdown="1">

### å¹¶è¡Œè®¡ç®—çš„æ–¹å¼

* è¿›ç¨‹
* çº¿ç¨‹
* åç¨‹(coroutine)/çº¤ç¨‹(fiber)
* Future/Task
* Async/Await
* Actor
* ... ...


</section>


<section markdown="1">

Oh, no! æˆ‘è¯¥æ€ä¹ˆé€‰ï¼Ÿ

</section>


<section markdown="1">


![](https://user-images.githubusercontent.com/12044174/105630587-07d51b00-5e85-11eb-8ede-ce3a487237d2.png)

**è¯·æ³¨æ„ï¼šè¿™é‡Œä¸æ˜¯åœ¨è®¨è®ºâ€œå…·ä½“çš„æŠ€æœ¯å®ç°â€ï¼Œæ˜¾ç„¶ä»»ä½•å½¢å¼çš„å¹¶è¡Œå¤„ç†éƒ½ä¸€å®šæ˜¯åŸºäºè¿›ç¨‹å’Œçº¿ç¨‹å®ç°çš„ã€‚è¿™é‡Œè¦è®¨è®ºçš„é—®é¢˜æ˜¯ï¼Œä»€ä¹ˆâ€œæ€ç»´æ–¹å¼â€æ‰å¯ä»¥åœ¨å¤šç§åœºæ™¯ä¸‹å§‹ç»ˆå¦‚ä¸€çš„åº”ç”¨ï¼Ÿæ˜¾ç„¶åœ¨åˆ†å¸ƒå¼/æµå¼åœºæ™¯ä¸‹ï¼Œåº•å±‚çš„å®ç°ä¸éœ€è¦ç‰¹åˆ«è®¨è®ºï¼ˆå°¤å…¶åœ¨ä½¿ç”¨å·²æœ‰æ¡†æ¶æ—¶ï¼‰ï¼Œè€Œæ›´éœ€è¦æ€è€ƒçš„æ˜¯â€œæ•°æ®çš„å¤„ç†æ–¹å¼â€ï¼Œè¿™é‡Œçš„å¤„ç†æ–¹å¼å³â€œæ€ç»´æ–¹å¼â€çš„æ˜ å°„ã€‚**


</section>

<section markdown="1">

From Akka:

> We believe that writing correct concurrent & distributed, resilient and elastic applications is too hard. Most of the time it's because we are using the **wrong tools** and the **wrong level of abstraction**.

</section>


<section markdown="1">

### `Functor`å¯ä»¥ç®€å•è§†ä½œå¯¹äº`map`çš„æŠ½è±¡

> Formally, a functor is a type **F[A]** with an operation **map** with type **(A => B) => F[B]**. 

```
trait Functor[F[_]]:
  extension [A, B](x: F[A])
    def map(f: A => B): F[B]
```

</section>

<section markdown="1">

Functor Laws:

> Functors guarantee the same semantics whether we sequence many small operations one by one, or combine them into a larger function before mapping. To ensure this is the case the following laws must hold:

* Identity: calling map with the identity function is the same as doing nothing:

`fa.map(a => a) == fa`

* Composition: mapping with two functions f and g is the same as mapping with f and then mapping with g:

`fa.map(g(f(_))) == fa.map(f).map(g)`

</section>

<section markdown="1">

### ä¸€ä¸ªå•å­(Monad)è¯´ç™½äº†ä¸è¿‡å°±æ˜¯è‡ªå‡½å­èŒƒç•´ä¸Šçš„ä¸€ä¸ªå¹ºåŠç¾¤è€Œå·²(ğŸ¶

> Monadic behaviour is formally captured in two operations: `pure` and `flatMap`:

```
trait Monad[F[_]] extends Functor[F]:

  def pure[A](x: A): F[A]

  extension [A, B](x: F[A])
    def flatMap(f: A => F[B]): F[B]

    def map(f: A => B): F[B] = x.flatMap(f.andThen(pure))
```

</section>

<section markdown="1">

Monad Laws:

> `pure` and `flatMap` must obey a set of laws that allow us to sequence operations freely without unintended glitches and side-effects:

* Left identity: calling `pure` and transforming the result with func is the same as calling func:

`pure(a).flatMap(func) == func(a)`

* Right identity: passing `pure` to flatMap is the same as doing nothing:

`m.flatMap(pure) == m`

* Associativity: flatMapping over two functions `f` and `g` is the same as flatMapping over `f` and then flatMapping over `g`:

`m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))`

</section>


<section markdown="1">

è¯´å¥½çš„å¹¶è¡Œè®¡ç®—å‘¢ï¼Ÿ

![???](https://th.bing.com/th/id/OIP.dPx8KZpS6RXz_I8nGePOrwAAAA?pid=Api&rs=1)

**è¿™é‡Œåªè®²äº†â€œè¯­ä¹‰â€ä¸Šçš„â€œå¹¶è¡Œâ€ï¼Œç»å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éƒ½ä¸éœ€è¦æ‰‹åŠ¨å®ç°ä¸€äº›å¹¶è¡Œæœºåˆ¶ï¼Œè€Œæ›´å¤šçš„æ˜¯ä½¿ç”¨å·²æœ‰çš„å·¥å…·ã€‚**

</section>


<section markdown="1">

å¦‚æœä½ éœ€è¦å¹¶è¡ŒåŒ–ä¸€ä¸ªæ–°çš„æ•°æ®ç»“æ„ï¼Œå¯ä»¥å‚è€ƒï¼š

* [Functional Programming In Scala: Purely functional parallelism](https://livebook.manning.com/book/functional-programming-in-scala/chapter-7/)
* [Cats: Parallel](https://typelevel.org/cats/typeclasses/parallel.html)
* Scalaz: Par

</section>


<section markdown="1">

## Thanks

</section>
